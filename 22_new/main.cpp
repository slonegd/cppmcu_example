/**
 * 22 стандартный оператор new
 **/

#include "defines.h"
#include "stm32f0xx.h"

// с make функциями выявилась следующая проблемма
// её работа основана на RVO (return value optimisation)
// созданный в ней объект возвращается без копирования
// когда появляются сложные классы, в приватных полях которых
// другие объекты, созданные с помощью таких же make
// RVO не срабатывает и происходит копирование объекта

// пример можно посмотреть тут
// https://wandbox.org/permlink/DJDvDXSJ3kgmb4YG
// в выводе видно, что для структуры А сработало RVO
// , но для этой же структуры в составе В уже нет
// видно по деструктору, который вызывается в середине
// не так страшно лишнее копирование, как то, что
// в make можно подписаться на какое-нибудь событие
// А это приведёт к тому, что издатель будет иметь
// в списке подписчиков, удалённый объект

// чтобы лишние копирования не происходили можно возвращать 
// из make указатель на созданный объект, а не его самого.
// А чтобы объект не удалялся при выходе из функции
// расположем его в куче с помощью оператора new.
 
// далее простой пример
int main()
{
   // сделаю volatile, чтобы не соптимизировал
   auto i = new volatile int{};
   *i = 1;
   // volatile int i{};
   // i = 1;
}

// результат компиляции -0s
// text    data     bss     dec     hex filename
//  984     108    1588    2680     a78 build/main.elf
// тот же main, но с расположением переменной на стеке (закомментированная часть) -0s
// text    data     bss     dec     hex filename
//  456       8    1568    2032     7f0 build/main.elf

// размер программы увеличился на 984-456=528 байт
// теперь посмотрим ассемблерный листинг выполнения для обоих случаев
// , чтобы убедиться, что размер увеличился не статически, для хранения неких данных
// для оператора

// вариант на стеке
// => 0x0800010a <main()+2>:	01 23	movs	r3, #1
// => 0x0800010c <main()+4>:	82 b0	sub	sp, #8
// => 0x0800010e <main()+6>:	01 90	str	r0, [sp, #4]
// => 0x08000110 <main()+8>:	01 93	str	r3, [sp, #4]
// => 0x08000112 <main()+10>:	02 b0	add	sp, #8
//    0x08000114 <main()+12>:	70 47	bx	lr

// вариант с оператором new
// => 0x0800010a <main()+2>:	04 20	movs	r0, #4
//    0x0800010c <main()+4>:	00 f0 2d f8	bl	0x800016a <_Znwj>
//    0x08000110 <main()+8>:	00 23	movs	r3, #0
// => 0x0800016a <_Znwj+0>:	10 b5	push	{r4, lr}
// => 0x0800016c <_Znwj+2>:	04 1e	subs	r4, r0, #0
// => 0x0800016e <_Znwj+4>:	00 d1	bne.n	0x8000172 <_Znwj+8>
// => 0x08000172 <_Znwj+8>:	20 00	movs	r0, r4
// => 0x08000174 <_Znwj+10>:	00 f0 3e f8	bl	0x80001f4 <malloc>
// => 0x080001f4 <malloc+0>:	10 b5	push	{r4, lr}
// => 0x080001f6 <malloc+2>:	03 4b	ldr	r3, [pc, #12]	; (0x8000204 <malloc+16>)
// => 0x080001f8 <malloc+4>:	01 00	movs	r1, r0
// => 0x080001fa <malloc+6>:	18 68	ldr	r0, [r3, #0]
// => 0x080001fc <malloc+8>:	00 f0 04 f8	bl	0x8000208 <_malloc_r>
// => 0x08000208 <_malloc_r+0>:	03 23	movs	r3, #3
// => 0x0800020a <_malloc_r+2>:	70 b5	push	{r4, r5, r6, lr}
// => 0x0800020c <_malloc_r+4>:	cd 1c	adds	r5, r1, #3
// => 0x0800020e <_malloc_r+6>:	9d 43	bics	r5, r3
// => 0x08000210 <_malloc_r+8>:	08 35	adds	r5, #8
// => 0x08000212 <_malloc_r+10>:	06 00	movs	r6, r0
// => 0x08000214 <_malloc_r+12>:	0c 2d	cmp	r5, #12
// => 0x08000216 <_malloc_r+14>:	1e d2	bcs.n	0x8000256 <_malloc_r+78>
// => 0x08000256 <_malloc_r+78>:	00 2d	cmp	r5, #0
// => 0x08000258 <_malloc_r+80>:	df da	bge.n	0x800021a <_malloc_r+18>
// => 0x0800021a <_malloc_r+18>:	a9 42	cmp	r1, r5
// => 0x0800021c <_malloc_r+20>:	1d d8	bhi.n	0x800025a <_malloc_r+82>
// => 0x0800021e <_malloc_r+22>:	30 00	movs	r0, r6
// => 0x08000220 <_malloc_r+24>:	00 f0 ac f8	bl	0x800037c <__malloc_lock>
// => 0x0800037c <__malloc_lock+0>:	70 47	bx	lr
// => 0x08000224 <_malloc_r+28>:	25 4a	ldr	r2, [pc, #148]	; (0x80002bc <_malloc_r+180>)
// => 0x08000226 <_malloc_r+30>:	14 68	ldr	r4, [r2, #0]
// => 0x08000228 <_malloc_r+32>:	21 00	movs	r1, r4
// => 0x0800022a <_malloc_r+34>:	00 29	cmp	r1, #0
// => 0x0800022c <_malloc_r+36>:	19 d1	bne.n	0x8000262 <_malloc_r+90>
// => 0x0800022e <_malloc_r+38>:	24 4c	ldr	r4, [pc, #144]	; (0x80002c0 <_malloc_r+184>)
// => 0x08000230 <_malloc_r+40>:	23 68	ldr	r3, [r4, #0]
// => 0x08000232 <_malloc_r+42>:	00 2b	cmp	r3, #0
// => 0x08000234 <_malloc_r+44>:	03 d1	bne.n	0x800023e <_malloc_r+54>
// => 0x08000236 <_malloc_r+46>:	30 00	movs	r0, r6
// => 0x08000238 <_malloc_r+48>:	00 f0 44 f8	bl	0x80002c4 <_sbrk_r>
// => 0x080002c4 <_sbrk_r+0>:	00 23	movs	r3, #0
// => 0x080002c6 <_sbrk_r+2>:	70 b5	push	{r4, r5, r6, lr}
// => 0x080002c8 <_sbrk_r+4>:	06 4c	ldr	r4, [pc, #24]	; (0x80002e4 <_sbrk_r+32>)
// => 0x080002ca <_sbrk_r+6>:	05 00	movs	r5, r0
// => 0x080002cc <_sbrk_r+8>:	08 00	movs	r0, r1
// => 0x080002ce <_sbrk_r+10>:	23 60	str	r3, [r4, #0]
// => 0x080002d0 <_sbrk_r+12>:	00 f0 66 f8	bl	0x80003a0 <_sbrk>
// => 0x080003a0 <_sbrk+0>:	04 4a	ldr	r2, [pc, #16]	; (0x80003b4 <_sbrk+20>)
// => 0x080003a2 <_sbrk+2>:	13 68	ldr	r3, [r2, #0]
// => 0x080003a4 <_sbrk+4>:	00 2b	cmp	r3, #0
// => 0x080003a6 <_sbrk+6>:	00 d1	bne.n	0x80003aa <_sbrk+10>
// => 0x080003a8 <_sbrk+8>:	03 4b	ldr	r3, [pc, #12]	; (0x80003b8 <_sbrk+24>)
// => 0x080003aa <_sbrk+10>:	18 18	adds	r0, r3, r0
// => 0x080003ac <_sbrk+12>:	10 60	str	r0, [r2, #0]
// => 0x080003ae <_sbrk+14>:	18 00	movs	r0, r3
// => 0x080003b0 <_sbrk+16>:	70 47	bx	lr
// => 0x080002d4 <_sbrk_r+16>:	43 1c	adds	r3, r0, #1
// => 0x080002d6 <_sbrk_r+18>:	03 d1	bne.n	0x80002e0 <_sbrk_r+28>
// => 0x080002e0 <_sbrk_r+28>:	70 bd	pop	{r4, r5, r6, pc}
// => 0x0800023c <_malloc_r+52>:	20 60	str	r0, [r4, #0]
// => 0x0800023e <_malloc_r+54>:	29 00	movs	r1, r5
// => 0x08000240 <_malloc_r+56>:	30 00	movs	r0, r6
// => 0x08000242 <_malloc_r+58>:	00 f0 3f f8	bl	0x80002c4 <_sbrk_r>
// => 0x080002c4 <_sbrk_r+0>:	00 23	movs	r3, #0
// => 0x080002c6 <_sbrk_r+2>:	70 b5	push	{r4, r5, r6, lr}
// => 0x080002c8 <_sbrk_r+4>:	06 4c	ldr	r4, [pc, #24]	; (0x80002e4 <_sbrk_r+32>)
// => 0x080002ca <_sbrk_r+6>:	05 00	movs	r5, r0
// => 0x080002cc <_sbrk_r+8>:	08 00	movs	r0, r1
// => 0x080002ce <_sbrk_r+10>:	23 60	str	r3, [r4, #0]
// => 0x080002d0 <_sbrk_r+12>:	00 f0 66 f8	bl	0x80003a0 <_sbrk>
// => 0x080003a0 <_sbrk+0>:	04 4a	ldr	r2, [pc, #16]	; (0x80003b4 <_sbrk+20>)
// => 0x080003a2 <_sbrk+2>:	13 68	ldr	r3, [r2, #0]
// => 0x080003a4 <_sbrk+4>:	00 2b	cmp	r3, #0
// => 0x080003a6 <_sbrk+6>:	00 d1	bne.n	0x80003aa <_sbrk+10>
// => 0x080003aa <_sbrk+10>:	18 18	adds	r0, r3, r0
// => 0x080003ac <_sbrk+12>:	10 60	str	r0, [r2, #0]
// => 0x080003ae <_sbrk+14>:	18 00	movs	r0, r3
// => 0x080003b0 <_sbrk+16>:	70 47	bx	lr
// => 0x080002d4 <_sbrk_r+16>:	43 1c	adds	r3, r0, #1
// => 0x080002d6 <_sbrk_r+18>:	03 d1	bne.n	0x80002e0 <_sbrk_r+28>
// => 0x080002e0 <_sbrk_r+28>:	70 bd	pop	{r4, r5, r6, pc}
// => 0x08000246 <_malloc_r+62>:	43 1c	adds	r3, r0, #1
// => 0x08000248 <_malloc_r+64>:	2b d1	bne.n	0x80002a2 <_malloc_r+154>
// => 0x080002a2 <_malloc_r+154>:	03 23	movs	r3, #3
// => 0x080002a4 <_malloc_r+156>:	c4 1c	adds	r4, r0, #3
// => 0x080002a6 <_malloc_r+158>:	9c 43	bics	r4, r3
// => 0x080002a8 <_malloc_r+160>:	a0 42	cmp	r0, r4
// => 0x080002aa <_malloc_r+162>:	e1 d0	beq.n	0x8000270 <_malloc_r+104>
// => 0x08000270 <_malloc_r+104>:	25 60	str	r5, [r4, #0]
// => 0x08000272 <_malloc_r+106>:	03 e0	b.n	0x800027c <_malloc_r+116>
// => 0x0800027c <_malloc_r+116>:	30 00	movs	r0, r6
// => 0x0800027e <_malloc_r+118>:	00 f0 7e f8	bl	0x800037e <__malloc_unlock>
// => 0x0800037e <__malloc_unlock+0>:	70 47	bx	lr
// => 0x08000282 <_malloc_r+122>:	20 00	movs	r0, r4
// => 0x08000284 <_malloc_r+124>:	07 22	movs	r2, #7
// => 0x08000286 <_malloc_r+126>:	0b 30	adds	r0, #11
// => 0x08000288 <_malloc_r+128>:	23 1d	adds	r3, r4, #4
// => 0x0800028a <_malloc_r+130>:	90 43	bics	r0, r2
// => 0x0800028c <_malloc_r+132>:	c3 1a	subs	r3, r0, r3
// => 0x0800028e <_malloc_r+134>:	e7 d0	beq.n	0x8000260 <_malloc_r+88>
// => 0x08000290 <_malloc_r+136>:	5a 42	negs	r2, r3
// => 0x08000292 <_malloc_r+138>:	e2 50	str	r2, [r4, r3]
// => 0x08000294 <_malloc_r+140>:	e4 e7	b.n	0x8000260 <_malloc_r+88>
// => 0x08000260 <_malloc_r+88>:	70 bd	pop	{r4, r5, r6, pc}
// => 0x08000200 <malloc+12>:	10 bd	pop	{r4, pc}
// => 0x08000178 <_Znwj+14>:	00 28	cmp	r0, #0
// => 0x0800017a <_Znwj+16>:	07 d1	bne.n	0x800018c <_Znwj+34>
// => 0x0800018c <_Znwj+34>:	10 bd	pop	{r4, pc}
// => 0x08000110 <main()+8>:	00 23	movs	r3, #0
// => 0x08000112 <main()+10>:	01 22	movs	r2, #1
// => 0x08000114 <main()+12>:	03 60	str	r3, [r0, #0]
// => 0x08000116 <main()+14>:	02 60	str	r2, [r0, #0]
// => 0x08000118 <main()+16>:	18 00	movs	r0, r3
//    0x0800011a <main()+18>:	10 bd	pop	{r4, pc}
//    0x08000118 <main()+16>:	18 00	movs	r0, r3
// => 0x0800011a <main()+18>:	10 bd	pop	{r4, pc}


// очевидно, что вариант с оператором сильно медленее
// можно сократить расходы, если определить собственный оператор new