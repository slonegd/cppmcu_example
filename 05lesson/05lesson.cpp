/**
 * 05lesson двунаправлленый список
 **/

#include <iostream>


// в прошлом примере с паттерном подписчик для хранения использовался
// стандартный контейнер std::list
// он использует для своей работы динамическое выделение памяти с помощью оператора new
// в микромире этот оператор не определён
// можно самому определить его, но это довольно сложная тема,
// поэтому стандартные контейнеры нам не доступны, придется писать свой.

// В stl двунаправленный список представляет из себя некоторе количество
// структур (Node), разбросанных беспорядочно в памяти.
// Чтобы была возможность найти все элементы, хранящиеся в контейнере,
// каждая Node хранит в себе указатель на предыдущую Node и на следующую

template<class T>
struct Node {
   T value;
   Node* prev;
   Node* next;
};

// Таким образом, если начать с первой Node, и пройтись по указателям next,
// пока next не будет nullptr, можно пройтись по всем Node в прямом порядке.
// Думаю понятно, как это сделать в обратном порядке. Только нужна структура,
// которая будет хранить указатель на первую Node и на последнюю

template<class T>
struct List_ {
   Node<T>* first;
   Node<T>* last;
};

// для того чтобы удалить Node из списка достаточно изменить указатели 
// prev->next = next; next->prev = prev;
// для вставки новой Node в конец списка
// prev = List::last; List::last = this;
// аналогично для вставки в начало
// Думаю теперь понятно, почему список называется двунаправленным.

// плюсы контейнера:
// + быстрая вставка
// + быстрое удаление
// + возможность последовательно пройтись по всем значениям
// минусы контейнера
// - доступ к произвольному элементу относительно долгая операция (кроме первого и последнего)


// Далее рассмотрим, как реализовать контейнер без динамического выделения памяти
// Память для хранения элементов уже будет выделена конструктором класса, который мы хотим хранить в списке
// Напишем базовый класс. При наследовании от него, новый класс будет хранить в себе
// указатели на предыдущий и следующий, как в Node. Само значение хранить не надо,
// так как объект класса и есть значение
template<class T>
struct Listable
{
   T* prev {nullptr};
   T* next {nullptr};
};

// класс самого листа
template<class T>
struct List
{
   // хранит значения на первый и последний, при создании инициализируется нулями, так как элементов ещё нет
   T* first {nullptr};
   T* last  {nullptr};

   // должен содержать метод добавления в конец списка
   void push_back (T* pobj)
   {
      pobj->prev = last;
      if (last)
         last->next = pobj;
      last = pobj;
      if (not first)                      // при добавлении первого элемента
         first = pobj;
   }
   // добавление в начало списка
   void push_front (T* pobj) {}           // реализацию не указываю
   // удаление из списка
   void remove (T* pobj)
   {
      if (pobj->prev and pobj->next) {    // если в серединке
         pobj->prev->next = pobj->next;
         pobj->next->prev = pobj->prev;
      } else if (pobj->next) {            // если первый
         first = pobj->next->prev;
      } else if (pobj->prev) {            // если последний
         last = pobj->prev->next;
      }
   }
};


// создадим тривиальную структуру
// наследуем её от базового Listable, чтобы хранить указатели на предыдущий и следующий 
struct A : Listable<A>
{
   // любые, необходимые нам поля и методы, самому листу о них ничего знать не надо
   // тут для удобства отслеживания будем хранить номер созданного объекта
   int n {0};
   // конструктор принимает в качестве аргумента, лист к которому надо добавиться
   A (List<A>& list) { list.push_back (this); }
   // метод, возвращающий адрес, для удобства отслеживания далее
   A* adr() { return this; }
};




int main ()
{
   List<A> list;
   A a1 {list};
   a1.n = 1;
   std::cout << "A a1 {list};" << std::endl;
   std::cout << list.first << ' ' << list.last << std::endl;
   std::cout << a1.adr() << ": " << a1.n << ' ' << a1.prev << ' ' << a1.next << std::endl;
   // пример вывода тут
   // A a1 {list};
   // 0x7ffce04510a0 0x7ffce04510a0
   // 0x7ffce04510a0: 1 0 0
   // list.first == list.last , потому что в списке всего 1 элемент
   // у самого элемента указатели на предыдущий и следующий нулевые, опять же потому что он 1
   A a2 {list};
   a2.n = 2;
   std::cout << "A a2 {list};" << std::endl;
   std::cout << list.first << ' ' << list.last << std::endl;
   std::cout << a1.adr() << ": "  << a1.n << ' ' << a1.prev << ' ' << a1.next << std::endl;
   std::cout << a2.adr() << ": "  << a2.n << ' ' << a2.prev << ' ' << a2.next << std::endl;
   // пример вывода тут
   // A a2 {list};
   // 0x7ffce04510a0 0x7ffce0451080
   // 0x7ffce04510a0: 1 0 0x7ffce0451080
   // 0x7ffce0451080: 2 0x7ffce04510a0 0
   // first и last уже отличается, первый указывает на первый, последний на второй
   // в первом элементе указатель на предыдущий нулевой, на следующий - адрес второго
   // во втором элементе указатель на предыдущий - адрес первого, на следующий нулевой
   A a3 {list};
   a2.n = 3;
   std::cout << "A a3 {list};" << std::endl;
   std::cout << list.first << ' ' << list.last << std::endl;
   std::cout << a1.adr() << ": "  << a1.n << ' ' << a1.prev << ' ' << a1.next << std::endl;
   std::cout << a2.adr() << ": "  << a2.n << ' ' << a2.prev << ' ' << a2.next << std::endl;
   std::cout << a3.adr() << ": "  << a3.n << ' ' << a3.prev << ' ' << a3.next << std::endl;
   // пример вывода тут
   // A a3 {list};
   // A a3 {list};
   // 0x7ffce04510a0 0x7ffce0451060
   // 0x7ffce04510a0: 1 0 0x7ffce0451080
   // 0x7ffce0451080: 2 0x7ffce04510a0 0x7ffce0451060
   // 0x7ffce0451060: 3 0x7ffce0451080 0
   // изменился указатель на последний - адрес третего
   // второй теперь указывает на третьего
   // а третий указывает только на второго
   list.remove (&a2);
   std::cout << "list.remove (&a2);" << std::endl;
   std::cout << list.first << ' ' << list.last << std::endl;
   std::cout << a1.adr() << ": "  << a1.n << ' ' << a1.prev << ' ' << a1.next << std::endl;
   std::cout << a3.adr() << ": "  << a3.n << ' ' << a3.prev << ' ' << a3.next << std::endl;
   // пример вывода тут
   // list.remove (&a2);
   // 0x7ffce04510a0 0x7ffce0451060
   // 0x7ffce04510a0: 1 0 0x7ffce0451060
   // 0x7ffce0451060: 3 0x7ffce04510a0 0
   // указатель на первый и последний не изменились, потому что удалялся из списка средний элемент
   // первый теперь указывает на третий
   // а третий на первый
}